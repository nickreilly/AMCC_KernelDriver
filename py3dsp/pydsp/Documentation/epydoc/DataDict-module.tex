%
% API Documentation for API Documentation
% Module DataDict
%
% Generated by epydoc 3.0alpha2
% [Thu Jul 20 16:44:53 2006]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{DataDict \textit{(module)}|(}
\section{Module DataDict}

    \label{DataDict}
DataDict.py

The DataDict overloads the regular dictionary (but does not inherit from 
it) by allowing a user to call a special function with special arguments 
whenever any of its values change.

This code was based from the UserDict code.  It could have inherited from 
UserDict; perhaps though it is easier to understand with it all right here.

NOTE: The latest Python versions allow derivation from built-in types. 
UserDict and DataDict are not needed anymore, and a rewrite should occur 
later on at some point.

The DataDict also allows attribute access to the dictionary.

Usage: Instantiating an instance of the class:

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict = DataDict()\end{alltt}

Adding an item, simplest form:

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict.additem("simple")
{\textgreater}{\textgreater}{\textgreater} mydict["simple"] \# default value is None
{\textgreater}{\textgreater}{\textgreater} print mydict["simple"]
None\end{alltt}

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict["simple"] = 42
{\textgreater}{\textgreater}{\textgreater} mydict["simple"]
42
{\textgreater}{\textgreater}{\textgreater} mydict.simple
42\end{alltt}

Reading an item that does not exist prints a message.

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict["notthere"]
Traceback (most recent call last):
  File "{\textless}stdin{\textgreater}", line 1, in ?
  File "DataDict.py", line 156, in \_\_getitem\_\_
    raise KeyError
KeyError: 'Key name notthere does not exist.'
{\textgreater}{\textgreater}{\textgreater} mydict.additem("withval",42)
{\textgreater}{\textgreater}{\textgreater} mydict["withval"]
42\end{alltt}

What happens when you write an item that does not exist? Unlike ordinary 
dictionaries, we want that to complain.

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict["notthere"] = 42
Traceback (most recent call last):
  File "{\textless}stdin{\textgreater}", line 1, in ?
  File "DataDict.py", line 160, in \_\_setitem\_\_
    raise KeyError
KeyError: 'Key name notthere does not exist.'\end{alltt}

Writing an unknown attribute should complain too; but it doesn't.

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict.notthere = 42 
{\textgreater}{\textgreater}{\textgreater} \end{alltt}

The action functions setfuncs and getfuncs hook assignment and retrieval 
into executable code. Lambda functions are used in this example and  are 
handy for simple setfuncs and getfuncs.

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict.additem("withget",42,getfunc = lambda : "spam")
{\textgreater}{\textgreater}{\textgreater} mydict.withget
'spam'
{\textgreater}{\textgreater}{\textgreater} mydict.withget = "eggs" \# try to write it, it seems to fail
{\textgreater}{\textgreater}{\textgreater} mydict["withget"] \# a read returns value from function
'spam'
{\textgreater}{\textgreater}{\textgreater} mydict.data["withget"] \# internally, it still knows last written value.
'eggs'\end{alltt}

You wont use a write-only variable like this very often, but several 
dictionary items can share the same setter function using arguments.

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} def setter(value, arg) : \# setter function, two args.
...     print value, arg
...
{\textgreater}{\textgreater}{\textgreater} mydict.additem("withset",42,setfunc = setter, args = ("cheese",))
{\textgreater}{\textgreater}{\textgreater} mydict.additem("withset2",42,setfunc = setter, args = ("grail",))
{\textgreater}{\textgreater}{\textgreater} mydict["withset"]  = "baloney"
baloney cheese
{\textgreater}{\textgreater}{\textgreater} mydict.withset2  = "baloney"
baloney grail\end{alltt}

A GUI hook for the whole dictionary can be set as well.

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict.set\_widget = setter \# we'll reuse setter for testing.\end{alltt}

Now accesses to any item calls the set\_widget function.  currently, 
"\_txt" is appended to each name. This reflects a pyshowall internal, and 
should probably be removed. The pyshowall set\_widget function hook would 
be more appropriate for adding the "\_txt"

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict["simple"] = "parrot"
simple\_txt parrot\end{alltt}

A namemap dictionary can alias a dict name to a widget name:

\begin{alltt}
{\textgreater}{\textgreater}{\textgreater} mydict.namemap = \{"simple":"complicated"\}
{\textgreater}{\textgreater}{\textgreater} mydict["simple"] = "bridgekeeper"
complicated\_txt bridgekeeper\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-v\-e\-r\-s\-i\-o\-n\-\_\-\_\- & \textbf{Value:} 
{\tt '\-{\textbackslash}\-n\-~\-~\-~\-~\-~\-\$\-I\-d\-:\-~\-D\-a\-t\-a\-D\-i\-c\-t\-.\-p\-y\-~\-3\-9\-9\-~\-2\-0\-0\-6\--\-0\-6\--\-0\-4\-~\-2\-0\-:\-0\-2\-:\-1\-7\-Z\-~\-d\-r\-e\-w\-~\-\$\-{\textbackslash}\-n\-'\-}&\\
\cline{1-2}
\raggedright \_\-\_\-a\-u\-t\-h\-o\-r\-\_\-\_\- & \textbf{Value:} 
{\tt '\-\$\-A\-u\-t\-h\-o\-r\-:\-~\-d\-r\-e\-w\-~\-\$\-'\-}&\\
\cline{1-2}
\raggedright \_\-\_\-U\-R\-L\-\_\-\_\- & \textbf{Value:} 
{\tt '\-\$\-U\-R\-L\-:\-~\-h\-t\-t\-p\-:\-/\-/\-a\-s\-t\-r\-o\-.\-p\-a\-s\-.\-r\-o\-c\-h\-e\-s\-t\-e\-r\-.\-e\-d\-u\-/\-s\-v\-n\-/\-p\-y\-d\-s\-p\-/\-t\-r\-u\-n\-k\-/\-p\-y\-d\-s\-p\-/\-D\-a\-t\-a\-D\-i\-c\-t\-.\-p\-y\-~\-\$\-'\-}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}|(}
\subsection{Class DataDict}

    \label{DataDict:DataDict}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{DataDict.DataDict}}
\end{tabular}

\textbf{Known Subclasses:}
det.DetDict,
    run.RunDict

Smart dictionary. Very similiar to Python properties.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{DataDict:DataDict:__cmp__}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.\_\_cmp\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_cmp\_\_}(\textit{self}, \textit{dict})

    \end{boxedminipage}

    \label{DataDict:DataDict:__contains__}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.\_\_contains\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_contains\_\_}(\textit{self}, \textit{key})

    \end{boxedminipage}

    \label{object:__delattr__}
    \index{object.\_\_delattr\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_delattr\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    x.\_\_delattr\_\_('name') {\textless}=={\textgreater} del x.name

    \vspace{1ex}

    \end{boxedminipage}

    \label{DataDict:DataDict:__delitem__}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.\_\_delitem\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_delitem\_\_}(\textit{self}, \textit{key})

    \end{boxedminipage}

    \label{DataDict:DataDict:__getattr__}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.\_\_getattr\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getattr\_\_}(\textit{self}, \textit{name})

    \end{boxedminipage}

    \label{object:__getattribute__}
    \index{object.\_\_getattribute\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getattribute\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    x.\_\_getattribute\_\_('name') {\textless}=={\textgreater} x.name

    \vspace{1ex}

    \end{boxedminipage}

    \label{DataDict:DataDict:__getitem__}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.\_\_getitem\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_getitem\_\_}(\textit{self}, \textit{name})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Recall a value from the smart dictionary.

    If the name has a getfunc, that function is called (with arguments if 
    arguments are defined for the name; the arguments are the same for 
    setfunc and getfunc) The return value of getfunc is returned to the 
    user. If no getfunc exists, the internal value associated with that 
    name is returned.

    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__hash__}
    \index{object.\_\_hash\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_hash\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    hash(x)

    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{dict}=\texttt{None})

    x.\_\_init\_\_(...) initializes x; see x.\_\_class\_\_.\_\_doc\_\_ for 
    signature

    \vspace{1ex}

      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{DataDict:DataDict:__iter__}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.\_\_iter\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_iter\_\_}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:__len__}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.\_\_len\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_len\_\_}(\textit{self})

    \end{boxedminipage}

    \label{object:__new__}
    \index{object.\_\_new\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_new\_\_}(\textit{T}, \textit{S}, \textit{...})

    \vspace{1ex}

      \textbf{Return Value}
      \begin{quote}
\begin{alltt}
a new object with type S, a subtype of T
\end{alltt}

      \end{quote}

    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__reduce__}
    \index{object.\_\_reduce\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reduce\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    helper for pickle

    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__reduce_ex__}
    \index{object.\_\_reduce\_ex\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_reduce\_ex\_\_}(\textit{...})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    helper for pickle

    \vspace{1ex}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_repr\_\_}(\textit{self})

    repr(x)

    \vspace{1ex}

      Overrides: object.\_\_repr\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setattr\_\_}(\textit{self}, \textit{name}, \textit{value})

    x.\_\_setattr\_\_('name', value) {\textless}=={\textgreater} x.name = 
    value

    \vspace{1ex}

      Overrides: object.\_\_setattr\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{DataDict:DataDict:__setitem__}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.\_\_setitem\_\_ \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_setitem\_\_}(\textit{self}, \textit{name}, \textit{val})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Assign a value to the smart dictionary.

    If a setfunc exists, that is called first (with args if they exist). 
    Successful setfunc execution is followed by remembering the value that 
    was written, then by an attempt to update a GUI via set\_widget (the 
    default set\_widget function does nothing.) The namemap can map 
    dictionary names to widget names if they are different; exceptions in 
    namemap or set\_widget are ignored.

    \vspace{1ex}

    \end{boxedminipage}

    \label{object:__str__}
    \index{object.\_\_str\_\_ \textit{(function)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{\_\_str\_\_}(\textit{x})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    str(x)

    \vspace{1ex}

    \end{boxedminipage}

    \label{DataDict:DataDict:additem}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.additem \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{additem}(\textit{self}, \textit{name}, \textit{val}=\texttt{None}, \textit{setfunc}=\texttt{None}, \textit{getfunc}=\texttt{None}, \textit{args}=\texttt{()}, \textit{kwds}=\texttt{None}, \textit{docstring}=\texttt{None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
    Put a new entry in the smart dictionary.

    name = string used to identify this thing val = initial value of item 
    setfunc: callable. If defined, it is called with new value on writes 
    getfunc: callable. If defined, it is called on reads args: if defined, 
    passed as last argument for setfunc and getfunc. docstring: help string
    for the item.

    \vspace{1ex}

    \end{boxedminipage}

    \label{DataDict:DataDict:clear}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.clear \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{clear}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:copy}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.copy \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{copy}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:get}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.get \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{get}(\textit{self}, \textit{key}, \textit{failobj}=\texttt{None})

    \end{boxedminipage}

    \label{DataDict:DataDict:has_key}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.has\_key \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{has\_key}(\textit{self}, \textit{key})

    \end{boxedminipage}

    \label{DataDict:DataDict:items}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.items \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{items}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:iteritems}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.iteritems \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{iteritems}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:iterkeys}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.iterkeys \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{iterkeys}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:itervalues}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.itervalues \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{itervalues}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:keys}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.keys \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{keys}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:popitem}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.popitem \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{popitem}(\textit{self})

    \end{boxedminipage}

    \label{DataDict:DataDict:set_widget}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.set\_widget \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{set\_widget}(\textit{self}, *\textit{args})

    \end{boxedminipage}

    \label{DataDict:DataDict:setdefault}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.setdefault \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{setdefault}(\textit{self}, \textit{key}, \textit{failobj}=\texttt{None})

    \end{boxedminipage}

    \label{DataDict:DataDict:update}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.update \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{update}(\textit{self}, \textit{dict})

    \end{boxedminipage}

    \label{DataDict:DataDict:values}
    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}!DataDict.DataDict.values \textit{(method)}}

    \vspace{0.5ex}

    \begin{boxedminipage}{\textwidth}

    \raggedright \textbf{values}(\textit{self})

    \end{boxedminipage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                            Class Variables                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Class Variables}

\begin{longtable}{|p{.30\textwidth}|p{.62\textwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-c\-l\-a\-s\-s\-\_\-\_\- & \textbf{Value:} 
{\tt {\textless}\-a\-t\-t\-r\-i\-b\-u\-t\-e\-~\-'\-\_\-\_\-c\-l\-a\-s\-s\-\_\-\_\-'\-~\-o\-f\-~\-'\-o\-b\-j\-e\-c\-t\-'\-~\-o\-b\-j\-e\-c\-t\-s\-{\textgreater}\-}&\\
\cline{1-2}
\raggedright n\-a\-m\-e\-m\-a\-p\- & \textbf{Value:} 
{\tt \{\-\}\-}&\\
\cline{1-2}
\end{longtable}

    \index{DataDict \textit{(module)}!DataDict.DataDict \textit{(class)}|)}
    \index{DataDict \textit{(module)}|)}
